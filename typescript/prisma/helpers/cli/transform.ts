/**
 * Aurora DSQL Migration Transformer for Prisma
 *
 * Transforms Prisma-generated SQL migrations to be DSQL-compatible by:
 * 1. Wrapping each statement in BEGIN/COMMIT (DSQL requires one DDL per transaction)
 * 2. Replacing CREATE INDEX with CREATE INDEX ASYNC
 * 3. Removing foreign key constraints (DSQL doesn't support them)
 *
 * Usage:
 *   npx prisma migrate diff ... --script | npm run dsql-transform
 *   npm run dsql-transform input.sql -o output.sql
 *
 * MAINTENANCE NOTE: These transformations are based on DSQL limitations documented at:
 * https://docs.aws.amazon.com/aurora-dsql/latest/userguide/working-with-postgresql-compatibility-unsupported-features.html
 */

export interface TransformOptions {
    /** Add header comment to output */
    includeHeader?: boolean;
    /** Force transformation even with unsupported statements */
    force?: boolean;
}

export interface TransformResult {
    sql: string;
    stats: {
        statementsProcessed: number;
        indexesConverted: number;
        foreignKeysRemoved: number;
    };
    warnings: string[];
    /** Unsupported statements that were encountered */
    unsupportedStatements: string[];
}

const HEADER_COMMENT = `-- Transformed for Aurora DSQL compatibility
-- Generated by aurora-dsql-prisma transform
--
-- Changes applied:
--   - Each statement wrapped in BEGIN/COMMIT (DSQL requires one DDL per transaction)
--   - CREATE INDEX converted to CREATE INDEX ASYNC (DSQL requires async index creation)
--   - Foreign key constraints removed (DSQL requires application-layer referential integrity use relationMode = "prisma")
--
`;

/**
 * Transforms Prisma-generated SQL to be DSQL-compatible.
 */
export function transformMigration(
    sql: string,
    options: TransformOptions = {},
): TransformResult {
    const { includeHeader = true, force = false } = options;

    const stats = {
        statementsProcessed: 0,
        indexesConverted: 0,
        foreignKeysRemoved: 0,
    };
    const warnings: string[] = [];
    const unsupportedStatements: string[] = [];

    // Parse SQL into statements
    const statements = parseSqlStatements(sql);

    // Transform each statement
    const transformedStatements: string[] = [];

    for (const stmt of statements) {
        const transformed = transformStatement(
            stmt,
            stats,
            unsupportedStatements,
            force,
        );
        if (transformed) {
            transformedStatements.push(transformed);
            stats.statementsProcessed++;
        }
    }

    // Build output
    let output = "";
    if (includeHeader && transformedStatements.length > 0) {
        output += HEADER_COMMENT;
    }
    output += transformedStatements.join("\n\n");
    output += "\n";

    // Add warning if foreign keys were removed
    if (stats.foreignKeysRemoved > 0) {
        warnings.push(
            `Removed ${stats.foreignKeysRemoved} foreign key constraint(s). ` +
                "DSQL requires application-layer referential integrity. " +
                'Ensure your Prisma schema has relationMode = "prisma" to handle this automatically.',
        );
    }

    return { sql: output, stats, warnings, unsupportedStatements };
}

/**
 * Parses SQL into individual statements, preserving comments.
 * Handles BEGIN/COMMIT blocks as single statements.
 */
function parseSqlStatements(sql: string): string[] {
    const statements: string[] = [];
    const lines = sql.split("\n");

    let currentStatement = "";
    let currentComments = "";
    let inBeginBlock = false;

    for (const line of lines) {
        const trimmed = line.trim();
        const upperTrimmed = trimmed.toUpperCase();

        // Skip empty lines between statements
        if (!trimmed && !currentStatement) {
            continue;
        }

        // Track BEGIN/COMMIT blocks
        if (upperTrimmed === "BEGIN;" || upperTrimmed === "BEGIN") {
            inBeginBlock = true;
        }

        // Collect comments that precede statements
        if (trimmed.startsWith("--") && !inBeginBlock) {
            if (currentStatement) {
                // Comment after statement started - part of statement
                currentStatement += "\n" + line;
            } else {
                // Comment before statement - collect it
                currentComments += (currentComments ? "\n" : "") + line;
            }
            continue;
        }

        // Add line to current statement
        currentStatement += (currentStatement ? "\n" : "") + line;

        // Check if we're ending a BEGIN block
        if (
            inBeginBlock &&
            (upperTrimmed === "COMMIT;" || upperTrimmed === "COMMIT")
        ) {
            const fullStatement = currentComments
                ? currentComments + "\n" + currentStatement
                : currentStatement;
            statements.push(fullStatement.trim());
            currentStatement = "";
            currentComments = "";
            inBeginBlock = false;
            continue;
        }

        // Check if statement is complete (ends with semicolon, not in BEGIN block)
        if (!inBeginBlock && trimmed.endsWith(";")) {
            const fullStatement = currentComments
                ? currentComments + "\n" + currentStatement
                : currentStatement;
            statements.push(fullStatement.trim());
            currentStatement = "";
            currentComments = "";
        }
    }

    // Handle any remaining content
    if (currentStatement.trim()) {
        const fullStatement = currentComments
            ? currentComments + "\n" + currentStatement
            : currentStatement;
        statements.push(fullStatement.trim());
    }

    return statements;
}

/**
 * Transforms a single SQL statement for DSQL compatibility.
 * Returns null if the statement should be removed.
 */
function transformStatement(
    statement: string,
    stats: TransformResult["stats"],
    unsupportedStatements: string[],
    force: boolean,
): string | null {
    // Skip if already wrapped in BEGIN/COMMIT
    if (/^\s*BEGIN\s*;/im.test(statement)) {
        return statement;
    }

    // Extract comment and SQL parts
    const { comment, sql } = extractComment(statement);

    // Remove foreign key statements
    if (isForeignKeyStatement(sql)) {
        stats.foreignKeysRemoved++;
        return null;
    }

    // Transform compound ALTER TABLE statements to remove unsupported clauses
    let transformedSql = transformAlterTable(sql, unsupportedStatements, force);

    // If ALTER TABLE was completely emptied, skip it
    if (!transformedSql) {
        return null;
    }

    // Transform CREATE INDEX to CREATE INDEX ASYNC
    if (
        isCreateIndexStatement(transformedSql) &&
        !transformedSql.toUpperCase().includes("ASYNC")
    ) {
        // Handle both CREATE INDEX and CREATE UNIQUE INDEX
        if (/CREATE\s+UNIQUE\s+INDEX/i.test(transformedSql)) {
            transformedSql = transformedSql.replace(
                /CREATE\s+UNIQUE\s+INDEX/gi,
                "CREATE UNIQUE INDEX ASYNC",
            );
        } else {
            transformedSql = transformedSql.replace(
                /CREATE\s+INDEX/gi,
                "CREATE INDEX ASYNC",
            );
        }
        stats.indexesConverted++;
    }

    // Wrap in BEGIN/COMMIT
    const wrapped = wrapInTransaction(transformedSql);

    // Re-add comment if present
    return comment ? `${comment}\n${wrapped}` : wrapped;
}

/**
 * Transforms ALTER TABLE statements to remove DSQL-unsupported clauses.
 * DSQL doesn't support DROP CONSTRAINT, so we track those and optionally remove them.
 * Returns null if the statement becomes empty after transformation.
 */
function transformAlterTable(
    sql: string,
    unsupportedStatements: string[],
    force: boolean,
): string | null {
    const normalized = sql.toUpperCase();

    // Only process ALTER TABLE statements with DROP CONSTRAINT
    if (
        !normalized.includes("ALTER TABLE") ||
        !normalized.includes("DROP CONSTRAINT")
    ) {
        return sql;
    }

    // Parse the ALTER TABLE statement to extract clauses
    // Format: ALTER TABLE "table" clause1, clause2, ...;
    // Note: Prisma always generates double-quoted identifiers for PostgreSQL
    const match = sql.match(/^(ALTER\s+TABLE\s+"[^"]+"\s+)(.+);?\s*$/is);
    if (!match) {
        return sql;
    }

    const prefix = match[1];
    const clausesPart = match[2].replace(/;$/, "");

    // Split clauses by comma, but be careful with nested parentheses
    const clauses = splitClauses(clausesPart);

    // Track unsupported clauses and filter them
    const filteredClauses: string[] = [];
    const droppedConstraints: string[] = [];

    for (const clause of clauses) {
        const upperClause = clause.toUpperCase().trim();

        // DROP CONSTRAINT is not supported by DSQL
        if (upperClause.startsWith("DROP CONSTRAINT")) {
            const fullStatement = `${prefix.trim()} ${clause.trim()}`;
            unsupportedStatements.push(fullStatement);
            // Extract constraint name for matching with ADD CONSTRAINT
            const constraintMatch = clause.match(
                /DROP\s+CONSTRAINT\s+"([^"]+)"/i,
            );
            if (constraintMatch) {
                droppedConstraints.push(constraintMatch[1].toUpperCase());
            }
            continue; // Always skip DROP CONSTRAINT
        }

        // ADD CONSTRAINT for primary keys - skip if paired with a DROP we're skipping
        if (
            upperClause.startsWith("ADD CONSTRAINT") &&
            upperClause.includes("PRIMARY KEY")
        ) {
            const constraintMatch = clause.match(
                /ADD\s+CONSTRAINT\s+"([^"]+)"/i,
            );
            const constraintName = constraintMatch
                ? constraintMatch[1].toUpperCase()
                : "";

            // If we're dropping and re-adding the same constraint, skip the ADD too
            if (droppedConstraints.includes(constraintName)) {
                if (force) {
                    continue; // With force, skip the re-add since we skipped the drop
                }
                // Without force, we'll fail anyway - don't include partial SQL
                continue;
            }
        }

        filteredClauses.push(clause);
    }

    // If no clauses left, return null to skip this statement
    if (filteredClauses.length === 0) {
        return null;
    }

    // Rebuild the statement
    return `${prefix}${filteredClauses.join(",\n")};`;
}

/**
 * Splits ALTER TABLE clauses by comma, respecting parentheses.
 */
function splitClauses(clausesPart: string): string[] {
    const clauses: string[] = [];
    let current = "";
    let depth = 0;

    for (const char of clausesPart) {
        if (char === "(") {
            depth++;
            current += char;
        } else if (char === ")") {
            depth--;
            current += char;
        } else if (char === "," && depth === 0) {
            clauses.push(current.trim());
            current = "";
        } else {
            current += char;
        }
    }

    if (current.trim()) {
        clauses.push(current.trim());
    }

    return clauses;
}

/**
 * Extracts leading comment from a statement.
 */
function extractComment(statement: string): { comment: string; sql: string } {
    const lines = statement.split("\n");
    const commentLines: string[] = [];
    const sqlLines: string[] = [];

    let inComment = true;
    for (const line of lines) {
        if (inComment && line.trim().startsWith("--")) {
            commentLines.push(line);
        } else {
            inComment = false;
            sqlLines.push(line);
        }
    }

    return {
        comment: commentLines.join("\n"),
        sql: sqlLines.join("\n").trim(),
    };
}

/**
 * Checks if a statement is a foreign key constraint (ADD or DROP).
 */
function isForeignKeyStatement(sql: string): boolean {
    const normalized = sql.toUpperCase();

    // ADD FOREIGN KEY patterns
    if (
        normalized.includes("FOREIGN KEY") ||
        (normalized.includes("ADD CONSTRAINT") &&
            normalized.includes("REFERENCES")) ||
        (normalized.includes("REFERENCES") &&
            normalized.includes("ON DELETE")) ||
        (normalized.includes("REFERENCES") && normalized.includes("ON UPDATE"))
    ) {
        return true;
    }

    // DROP CONSTRAINT for foreign keys (Prisma names them with _fkey suffix)
    if (
        normalized.includes("DROP CONSTRAINT") &&
        normalized.includes("_FKEY")
    ) {
        return true;
    }

    return false;
}

/**
 * Checks if a statement is a CREATE INDEX statement.
 */
function isCreateIndexStatement(sql: string): boolean {
    return /CREATE\s+(UNIQUE\s+)?INDEX/i.test(sql);
}

/**
 * Wraps a SQL statement in BEGIN/COMMIT.
 */
function wrapInTransaction(sql: string): string {
    const trimmed = sql.trim();
    // Ensure statement ends with semicolon
    const withSemicolon = trimmed.endsWith(";") ? trimmed : trimmed + ";";
    return `BEGIN;\n${withSemicolon}\nCOMMIT;`;
}

/**
 * Formats transformation stats for console output.
 */
export function formatTransformStats(
    stats: TransformResult["stats"],
    warnings: TransformResult["warnings"] = [],
): string {
    const lines: string[] = [];

    lines.push(`✓ Transformed ${stats.statementsProcessed} statement(s)`);

    if (stats.indexesConverted > 0) {
        lines.push(
            `  → Converted ${stats.indexesConverted} index(es) to ASYNC`,
        );
    }

    if (stats.foreignKeysRemoved > 0) {
        lines.push(
            `  → Removed ${stats.foreignKeysRemoved} foreign key constraint(s)`,
        );
    }

    // Add warnings
    for (const warning of warnings) {
        lines.push(`⚠ ${warning}`);
    }

    return lines.join("\n");
}
